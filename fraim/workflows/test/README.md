# Fraim Workflow Testing System

This directory contains the testing framework for Fraim's security workflows. The system provides deterministic, reproducible testing of AI-powered security analysis workflows using **VCR.py** to record and replay HTTP interactions.

## Architecture

### Directory Structure

```
fraim/workflows/
├── code/                           # Code security workflow
│   ├── workflow.py                 # Workflow implementation
│   └── test_cases/                 # Test cases for this workflow
│       └── basic_security/         # Example test case
│           ├── input/              # Test input files
│           │   └── vulnerable.py   # Simple vulnerable Python code
│           └── output/             # Expected outputs (generated by recorder)
│               ├── cassette.yaml   # Recorded HTTP interactions
│               └── expected.sarif  # Expected SARIF results
└── test/                           # Testing framework (machinery only)
    └── core/
        ├── executor.py             # Runs tests with VCR playback
        ├── recorder.py             # Records baselines with live APIs
        ├── runner.py               # Test orchestration
        ├── test_specification.py   # Test case definitions
        └── types.py                # Common types
```

### Core Components

- **`recorder.py`** - Records test baselines by running workflows with live APIs
- **`executor.py`** - Executes tests by replaying recorded HTTP interactions  
- **`runner.py`** - Orchestrates recording and execution of test suites

## How It Works

### 1. Recording Test Baselines
Create test data with real API calls:

```bash
uv run scripts/run_workflow_tests.py --record code:basic_security
```

**Process:**
1. Runs fraim workflow against `input/` files with real API calls
2. VCR records all HTTP interactions to `cassette.yaml` 
3. Captures SARIF results as expected baseline
4. Saves everything to `output/` directory

### 2. Running Tests
Validate against recorded baselines:

```bash
uv run scripts/run_workflow_tests.py --test code:basic_security
```

**Process:**
1. Loads recorded cassette and expected SARIF output
2. Runs fraim workflow with VCR replaying HTTP interactions (no live API calls)
3. Compares actual SARIF results against expected baseline
4. Reports success/failure with detailed differences

## Usage Examples

### Creating Test Cases
```bash
# 1. Create test input files
mkdir -p fraim/workflows/{workflow}/test_cases/{test}/input
echo "vulnerable_code_here" > fraim/workflows/{workflow}/test_cases/{test}/input/app.py

# 2. Record baseline  
uv run scripts/run_workflow_tests.py --record code:my_test

# 3. Run test
uv run scripts/run_workflow_tests.py --test code:my_test
```

## Key Design Decisions

### VCR.py Benefits
- **Deterministic** - Tests always produce identical results
- **Fast** - No network latency or API rate limits
- **Offline** - No API keys needed for CI/CD
- **Cost-effective** - No LLM API usage during testing

### Direct Function Calls
VCR works by monkey-patching HTTP libraries in the current process. The framework calls fraim's `scan()` function directly instead of using subprocess to ensure VCR can intercept HTTP requests.

### Single Process Mode
Multiprocessing interferes with VCR's monkey-patching. The framework sets `processes=1` in fraim's config for VCR compatibility.

## Security Considerations

### API Key Handling
- **Recording phase**: Cassettes will contain real API keys by default
- **Testing phase**: No API keys needed (uses recorded interactions)
- **Important**: Use VCR filtering to prevent sensitive data from being saved

### VCR Filtering
VCR can filter sensitive data before recording. Use `filter_headers` for sensitive headers (like `authorization`, `x-api-key`) and `filter_query_parameters` for sensitive URL parameters (like Gemini's `key` parameter).
